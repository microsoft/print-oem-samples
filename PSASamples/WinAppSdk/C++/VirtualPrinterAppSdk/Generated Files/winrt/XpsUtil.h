// WARNING: Please don't edit this file. It was generated by C++/WinRT v2.0.240405.15

#pragma once
#ifndef WINRT_XpsUtil_H
#define WINRT_XpsUtil_H
#include "winrt/base.h"
static_assert(winrt::check_version(CPPWINRT_VERSION, "2.0.240405.15"), "Mismatched C++/WinRT headers.");
#define CPPWINRT_VERSION "2.0.240405.15"
#include "winrt/impl/Windows.Foundation.2.h"
#include "winrt/impl/Windows.Graphics.Printing.Workflow.2.h"
#include "winrt/impl/Windows.Storage.Streams.2.h"
#include "winrt/impl/XpsUtil.2.h"
namespace winrt::impl
{
    template <typename D> auto consume_XpsUtil_IXpsPageWatermarker<D>::SetWatermarkText(param::hstring const& text, double fontSize, double xRelativeOffset, double yRelativeOffset) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::XpsUtil::IXpsPageWatermarker)->SetWatermarkText(*(void**)(&text), fontSize, xRelativeOffset, yRelativeOffset));
    }
    template <typename D> auto consume_XpsUtil_IXpsPageWatermarker<D>::SetWatermarkImage(param::hstring const& imagePath, double dpiX, double dpiY, int32_t width, int32_t height) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::XpsUtil::IXpsPageWatermarker)->SetWatermarkImage(*(void**)(&imagePath), dpiX, dpiY, width, height));
    }
    template <typename D> auto consume_XpsUtil_IXpsPageWatermarker<D>::SetWatermarkImageEnabled(bool enabled) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::XpsUtil::IXpsPageWatermarker)->SetWatermarkImageEnabled(enabled));
    }
    template <typename D> auto consume_XpsUtil_IXpsPageWatermarker<D>::ApplyWatermarks(winrt::XpsUtil::XpsPageWrapper const& page) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::XpsUtil::IXpsPageWatermarker)->ApplyWatermarks(*(void**)(&page)));
    }
    template <typename D> auto consume_XpsUtil_IXpsPageWrapper<D>::Clone() const
    {
        void* result{};
        check_hresult(WINRT_IMPL_SHIM(winrt::XpsUtil::IXpsPageWrapper)->Clone(&result));
        return winrt::XpsUtil::XpsPageWrapper{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_XpsUtil_IXpsPageWrapper<D>::RenderPageToBMP() const
    {
        void* result{};
        check_hresult(WINRT_IMPL_SHIM(winrt::XpsUtil::IXpsPageWrapper)->RenderPageToBMP(&result));
        return winrt::Windows::Storage::Streams::IRandomAccessStream{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_XpsUtil_IXpsSequentialDocument<D>::StartXpsOMGeneration() const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::XpsUtil::IXpsSequentialDocument)->StartXpsOMGeneration());
    }
    template <typename D> auto consume_XpsUtil_IXpsSequentialDocument<D>::GetWatermarkedStream(winrt::XpsUtil::XpsPageWatermarker const& watermarker) const
    {
        void* result{};
        check_hresult(WINRT_IMPL_SHIM(winrt::XpsUtil::IXpsSequentialDocument)->GetWatermarkedStream(*(void**)(&watermarker), &result));
        return winrt::Windows::Storage::Streams::IInputStream{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_XpsUtil_IXpsSequentialDocument<D>::GetPage(uint32_t pageNumber) const
    {
        void* result{};
        check_hresult(WINRT_IMPL_SHIM(winrt::XpsUtil::IXpsSequentialDocument)->GetPage(pageNumber, &result));
        return winrt::XpsUtil::XpsPageWrapper{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_XpsUtil_IXpsSequentialDocument<D>::PageCount() const
    {
        uint32_t result{};
        check_hresult(WINRT_IMPL_SHIM(winrt::XpsUtil::IXpsSequentialDocument)->PageCount(&result));
        return result;
    }
    template <typename D> auto consume_XpsUtil_IXpsSequentialDocument<D>::PageAdded(winrt::Windows::Foundation::TypedEventHandler<winrt::XpsUtil::XpsSequentialDocument, uint32_t> const& handler) const
    {
        winrt::event_token token{};
        check_hresult(WINRT_IMPL_SHIM(winrt::XpsUtil::IXpsSequentialDocument)->add_PageAdded(*(void**)(&handler), put_abi(token)));
        return token;
    }
    template <typename D> auto consume_XpsUtil_IXpsSequentialDocument<D>::PageAdded(auto_revoke_t, winrt::Windows::Foundation::TypedEventHandler<winrt::XpsUtil::XpsSequentialDocument, uint32_t> const& handler) const
    {
        return impl::make_event_revoker<D, PageAdded_revoker>(this, PageAdded(handler));
    }
    template <typename D> auto consume_XpsUtil_IXpsSequentialDocument<D>::PageAdded(winrt::event_token const& token) const noexcept
    {
        WINRT_IMPL_SHIM(winrt::XpsUtil::IXpsSequentialDocument)->remove_PageAdded(impl::bind_in(token));
    }
    template <typename D> auto consume_XpsUtil_IXpsSequentialDocument<D>::DocumentClosed(winrt::Windows::Foundation::TypedEventHandler<winrt::XpsUtil::XpsSequentialDocument, uint32_t> const& handler) const
    {
        winrt::event_token token{};
        check_hresult(WINRT_IMPL_SHIM(winrt::XpsUtil::IXpsSequentialDocument)->add_DocumentClosed(*(void**)(&handler), put_abi(token)));
        return token;
    }
    template <typename D> auto consume_XpsUtil_IXpsSequentialDocument<D>::DocumentClosed(auto_revoke_t, winrt::Windows::Foundation::TypedEventHandler<winrt::XpsUtil::XpsSequentialDocument, uint32_t> const& handler) const
    {
        return impl::make_event_revoker<D, DocumentClosed_revoker>(this, DocumentClosed(handler));
    }
    template <typename D> auto consume_XpsUtil_IXpsSequentialDocument<D>::DocumentClosed(winrt::event_token const& token) const noexcept
    {
        WINRT_IMPL_SHIM(winrt::XpsUtil::IXpsSequentialDocument)->remove_DocumentClosed(impl::bind_in(token));
    }
    template <typename D> auto consume_XpsUtil_IXpsSequentialDocument<D>::XpsGenerationFailed(winrt::Windows::Foundation::TypedEventHandler<winrt::XpsUtil::XpsSequentialDocument, uint64_t> const& handler) const
    {
        winrt::event_token token{};
        check_hresult(WINRT_IMPL_SHIM(winrt::XpsUtil::IXpsSequentialDocument)->add_XpsGenerationFailed(*(void**)(&handler), put_abi(token)));
        return token;
    }
    template <typename D> auto consume_XpsUtil_IXpsSequentialDocument<D>::XpsGenerationFailed(auto_revoke_t, winrt::Windows::Foundation::TypedEventHandler<winrt::XpsUtil::XpsSequentialDocument, uint64_t> const& handler) const
    {
        return impl::make_event_revoker<D, XpsGenerationFailed_revoker>(this, XpsGenerationFailed(handler));
    }
    template <typename D> auto consume_XpsUtil_IXpsSequentialDocument<D>::XpsGenerationFailed(winrt::event_token const& token) const noexcept
    {
        WINRT_IMPL_SHIM(winrt::XpsUtil::IXpsSequentialDocument)->remove_XpsGenerationFailed(impl::bind_in(token));
    }
    template <typename D> auto consume_XpsUtil_IXpsSequentialDocumentFactory<D>::CreateInstance(winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowObjectModelSourceFileContent const& sourceFileContent) const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::XpsUtil::IXpsSequentialDocumentFactory)->CreateInstance(*(void**)(&sourceFileContent), &value));
        return winrt::XpsUtil::XpsSequentialDocument{ value, take_ownership_from_abi };
    }
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::XpsUtil::IXpsPageWatermarker> : produce_base<D, winrt::XpsUtil::IXpsPageWatermarker>
    {
        int32_t __stdcall SetWatermarkText(void* text, double fontSize, double xRelativeOffset, double yRelativeOffset) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().SetWatermarkText(*reinterpret_cast<hstring const*>(&text), fontSize, xRelativeOffset, yRelativeOffset);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall SetWatermarkImage(void* imagePath, double dpiX, double dpiY, int32_t width, int32_t height) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().SetWatermarkImage(*reinterpret_cast<hstring const*>(&imagePath), dpiX, dpiY, width, height);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall SetWatermarkImageEnabled(bool enabled) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().SetWatermarkImageEnabled(enabled);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall ApplyWatermarks(void* page) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ApplyWatermarks(*reinterpret_cast<winrt::XpsUtil::XpsPageWrapper const*>(&page));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::XpsUtil::IXpsPageWrapper> : produce_base<D, winrt::XpsUtil::IXpsPageWrapper>
    {
        int32_t __stdcall Clone(void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::XpsUtil::XpsPageWrapper>(this->shim().Clone());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall RenderPageToBMP(void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::Storage::Streams::IRandomAccessStream>(this->shim().RenderPageToBMP());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::XpsUtil::IXpsSequentialDocument> : produce_base<D, winrt::XpsUtil::IXpsSequentialDocument>
    {
        int32_t __stdcall StartXpsOMGeneration() noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().StartXpsOMGeneration();
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall GetWatermarkedStream(void* watermarker, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::Storage::Streams::IInputStream>(this->shim().GetWatermarkedStream(*reinterpret_cast<winrt::XpsUtil::XpsPageWatermarker const*>(&watermarker)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall GetPage(uint32_t pageNumber, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::XpsUtil::XpsPageWrapper>(this->shim().GetPage(pageNumber));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall PageCount(uint32_t* result) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *result = detach_from<uint32_t>(this->shim().PageCount());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall add_PageAdded(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().PageAdded(*reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<winrt::XpsUtil::XpsSequentialDocument, uint32_t> const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_PageAdded(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().PageAdded(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
        int32_t __stdcall add_DocumentClosed(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().DocumentClosed(*reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<winrt::XpsUtil::XpsSequentialDocument, uint32_t> const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_DocumentClosed(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DocumentClosed(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
        int32_t __stdcall add_XpsGenerationFailed(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().XpsGenerationFailed(*reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<winrt::XpsUtil::XpsSequentialDocument, uint64_t> const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_XpsGenerationFailed(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().XpsGenerationFailed(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::XpsUtil::IXpsSequentialDocumentFactory> : produce_base<D, winrt::XpsUtil::IXpsSequentialDocumentFactory>
    {
        int32_t __stdcall CreateInstance(void* sourceFileContent, void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::XpsUtil::XpsSequentialDocument>(this->shim().CreateInstance(*reinterpret_cast<winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowObjectModelSourceFileContent const*>(&sourceFileContent)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
}
WINRT_EXPORT namespace winrt::XpsUtil
{
    inline XpsPageWatermarker::XpsPageWatermarker() :
        XpsPageWatermarker(impl::call_factory_cast<XpsPageWatermarker(*)(winrt::Windows::Foundation::IActivationFactory const&), XpsPageWatermarker>([](winrt::Windows::Foundation::IActivationFactory const& f) { return f.template ActivateInstance<XpsPageWatermarker>(); }))
    {
    }
    inline XpsSequentialDocument::XpsSequentialDocument(winrt::Windows::Graphics::Printing::Workflow::PrintWorkflowObjectModelSourceFileContent const& sourceFileContent) :
        XpsSequentialDocument(impl::call_factory<XpsSequentialDocument, IXpsSequentialDocumentFactory>([&](IXpsSequentialDocumentFactory const& f) { return f.CreateInstance(sourceFileContent); }))
    {
    }
}
namespace std
{
#ifndef WINRT_LEAN_AND_MEAN
    template<> struct hash<winrt::XpsUtil::IXpsPageWatermarker> : winrt::impl::hash_base {};
    template<> struct hash<winrt::XpsUtil::IXpsPageWrapper> : winrt::impl::hash_base {};
    template<> struct hash<winrt::XpsUtil::IXpsSequentialDocument> : winrt::impl::hash_base {};
    template<> struct hash<winrt::XpsUtil::IXpsSequentialDocumentFactory> : winrt::impl::hash_base {};
    template<> struct hash<winrt::XpsUtil::XpsPageWatermarker> : winrt::impl::hash_base {};
    template<> struct hash<winrt::XpsUtil::XpsPageWrapper> : winrt::impl::hash_base {};
    template<> struct hash<winrt::XpsUtil::XpsSequentialDocument> : winrt::impl::hash_base {};
#endif
#ifdef __cpp_lib_format
#endif
}
#endif
